<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AR.js - Car Moving Between 3 Markers (Local)</title>
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/jeromeetienne/ar.js/aframe/build/aframe-ar.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
<a-scene embedded arjs>
  
  <!-- Marker 1 (rodzic samochodu) -->
  <a-marker preset="hiro" id="marker1">
    <a-entity id="car-container">

      <!-- Niebieska rurka w marker1 (dla testów) -->
      <a-cylinder 
        height="2" 
        radius="0.1" 
        color="blue" 
        position="0 1 0">
      </a-cylinder>

      <!-- Samochód w marker1 -->
      <a-entity
        id="movingCar"
        gltf-model="car2.glb"
        scale="0.2 0.2 0.2"
        visible="false">
      </a-entity>

    </a-entity>
  </a-marker>

  <!-- Marker 2 -->
  <a-marker preset="kanji" id="marker2">
    <a-cylinder 
      height="2" 
      radius="0.1" 
      color="red" 
      position="0 1 0">
    </a-cylinder>
  </a-marker>

  <!-- Marker 3 (custom) -->
  <a-marker 
    preset="custom"
    type="pattern"
    url="custom-marker.patt"
    id="marker3">
    <a-cylinder
      height="2"
      radius="0.1"
      color="green"
      position="0 1 0">
    </a-cylinder>
  </a-marker>

  <!-- Kamera -->
  <a-entity camera></a-entity>

  <script>
    const marker1 = document.querySelector('#marker1');
    const marker2 = document.querySelector('#marker2');
    const marker3 = document.querySelector('#marker3');

    const car   = document.querySelector('#movingCar');
    const carContainer = document.querySelector('#car-container');

    // Flagi widoczności
    let isMarker1Visible = false;
    let isMarker2Visible = false;
    let isMarker3Visible = false;

    // Nasłuchiwanie zdarzeń
    marker1.addEventListener('markerFound', () => { isMarker1Visible = true; });
    marker1.addEventListener('markerLost',  () => { isMarker1Visible = false; });
    marker2.addEventListener('markerFound', () => { isMarker2Visible = true; });
    marker2.addEventListener('markerLost',  () => { isMarker2Visible = false; });
    marker3.addEventListener('markerFound', () => { isMarker3Visible = true; });
    marker3.addEventListener('markerLost',  () => { isMarker3Visible = false; });

    // progress: [0..3] (3 segmenty)
    //  - [0..1) segment 0: jedziemy z (0,0,0) do localPos2
    //  - [1..2) segment 1: jedziemy z localPos2 do localPos3
    //  - [2..3] segment 2: jedziemy z localPos3 do (0,0,0)
    let progress = 0;

    // direction: 1 (jazda "naprzód" po segmentach) lub -1 (jazda wstecz)
    let direction = 1;

    let animationFrame;

    function moveCar() {
      // Jeżeli marker1 (rodzic) nie jest widoczny, chowamy auto i nie ma co liczyć
      if (!isMarker1Visible) {
        car.setAttribute('visible', 'false');
        animationFrame = requestAnimationFrame(moveCar);
        return;
      }

      // Jeśli marker1 jest widoczny, możemy przeliczyć położenia markerów
      // w LOCALU marker1 (tak samo jak w przykładzie dwumarkerowym)
      // tylko jeśli dany marker (2 lub 3) jest widoczny w danym momencie.
      let localPos2 = new THREE.Vector3(0,0,0);
      let localPos3 = new THREE.Vector3(0,0,0);

      if (isMarker2Visible) {
        const worldPos2 = new THREE.Vector3();
        marker2.object3D.getWorldPosition(worldPos2);
        localPos2 = marker1.object3D.worldToLocal(worldPos2.clone());
      }

      if (isMarker3Visible) {
        const worldPos3 = new THREE.Vector3();
        marker3.object3D.getWorldPosition(worldPos3);
        localPos3 = marker1.object3D.worldToLocal(worldPos3.clone());
      }

      // Ustalamy, w którym segmencie ruchu jesteśmy
      // (0 -> 1 -> 2 w zależności od progress)
      const segment = Math.floor(progress);       // 0, 1 lub 2
      const segmentProgress = progress - segment; // np. 1.3 -> 0.3 w segmencie 1

      // Definicja punktów start/end w LOCALU marker1
      let startPos = new THREE.Vector3();
      let endPos   = new THREE.Vector3();

      // Domyślnie ukrywamy - dopiero jeśli segment "jest obsługiwany" i oba markery
      // danego odcinka są widoczne - pokażemy auto.
      let showCar = false;

      if (segment === 0) {
        // Ruch z (0,0,0) do localPos2
        // Warunek widoczności: marker1 i marker2
        if (isMarker2Visible) {
          showCar = true;
          startPos.set(0,0,0);
          endPos.copy(localPos2);
        }
      }
      else if (segment === 1) {
        // Ruch z localPos2 do localPos3
        // Warunek widoczności: marker1, marker2 i marker3
        // ALE tak jak w wersji dwumarkerowej - "potrzebne" są 2,
        // bo bez marker2 i marker3 nie wiemy skąd dokąd:
        if (isMarker2Visible && isMarker3Visible) {
          showCar = true;
          startPos.copy(localPos2);
          endPos.copy(localPos3);
        }
      }
      else {
        // segment === 2
        // Ruch z localPos3 do (0,0,0)
        // Warunek widoczności: marker1 i marker3
        if (isMarker3Visible) {
          showCar = true;
          startPos.copy(localPos3);
          endPos.set(0,0,0);
        }
      }

      if (showCar) {
        car.setAttribute('visible', 'true');

        // Interpolacja liniowa od startPos do endPos
        const x = THREE.MathUtils.lerp(startPos.x, endPos.x, segmentProgress);
        const y = THREE.MathUtils.lerp(startPos.y, endPos.y, segmentProgress);
        const z = THREE.MathUtils.lerp(startPos.z, endPos.z, segmentProgress);

        car.object3D.position.set(x, y, z);

        // Wyznaczamy kąt w planie XZ
        let angle = Math.atan2(endPos.z - startPos.z, endPos.x - startPos.x);
        // Jeśli jedziemy wstecz, odwracamy o 180 stopni
        if (direction === -1) {
          angle += Math.PI;
        }
        // A-Frame/Three.js -> negacja osi Y
        car.object3D.rotation.set(0, -angle, 0);

      } else {
        // Jeśli nie spełniono warunków widoczności w danym segmencie, chowamy auto
        car.setAttribute('visible', 'false');
      }

      // Aktualizacja progress
      progress += 0.01 * direction;

      // Gdy dojedziemy do końca (3), zawracamy
      if (progress > 3) {
        progress = 3;
        direction = -1;
      }
      // Gdy cofamy i dojedziemy do 0, zmieniamy kierunek na przód
      else if (progress < 0) {
        progress = 0;
        direction = 1;
      }

      animationFrame = requestAnimationFrame(moveCar);
    }

    moveCar();
    window.addEventListener('unload', () => cancelAnimationFrame(animationFrame));
  </script>
</a-scene>
</body>
</html>
