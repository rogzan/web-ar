<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR.js - Car Moving Between Markers</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/jeromeetienne/ar.js/aframe/build/aframe-ar.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <a-scene embedded arjs>
        <!-- Marker 1 (start) -->
        <a-marker preset="hiro" id="marker1">
            <a-entity id="car-container">
                <!-- Niebieska rurka w marker1 -->
                <a-cylinder height="2" radius="0.1" color="blue" position="0 1 0"></a-cylinder>
                <!-- Samochód w marker1 -->
                <a-entity id="movingCar" gltf-model="car2.glb" scale="0.2 0.2 0.2"></a-entity>
            </a-entity>
        </a-marker>

        <!-- Marker 2 (middle) -->
        <a-marker preset="kanji" id="marker2">
            <a-cylinder height="2" radius="0.1" color="red" position="0 1 0"></a-cylinder>
        </a-marker>

        <!-- Marker 3 (custom) -->
        <a-marker preset="custom" type="pattern" url="custom-marker.patt" id="marker3">
            <a-cylinder height="2" radius="0.1" color="green" position="0 1 0"></a-cylinder>
        </a-marker>

        <a-entity camera></a-entity>

        <script>
            const marker1 = document.querySelector('#marker1');
            const marker2 = document.querySelector('#marker2');
            const marker3 = document.querySelector('#marker3');
            const car = document.querySelector('#movingCar');
            const carContainer = document.querySelector('#car-container');

            let isMarker1Visible = false;
            let isMarker2Visible = false;
            let isMarker3Visible = false;

            let progress = 0;   // 0 - przy marker1, 1 - przy marker2, 2 - przy marker3
            let direction = 1;  // 1 - do przodu, -1 - wstecz

            let animationFrame;

            marker1.addEventListener('markerFound', () => isMarker1Visible = true);
            marker1.addEventListener('markerLost', () => isMarker1Visible = false);
            marker2.addEventListener('markerFound', () => isMarker2Visible = true);
            marker2.addEventListener('markerLost', () => isMarker2Visible = false);
            marker3.addEventListener('markerFound', () => isMarker3Visible = true);
            marker3.addEventListener('markerLost', () => isMarker3Visible = false);

            function moveCar() {
                if (isMarker1Visible && isMarker2Visible && isMarker3Visible) {
                    car.setAttribute('visible', 'true');
            
                    // Pobieranie pozycji markerów
                    const worldPos1 = new THREE.Vector3();
                    const worldPos2 = new THREE.Vector3();
                    const worldPos3 = new THREE.Vector3();
            
                    marker1.object3D.getWorldPosition(worldPos1);
                    marker2.object3D.getWorldPosition(worldPos2);
                    marker3.object3D.getWorldPosition(worldPos3);
            
                    // Tablica pozycji markerów w kolejności
                    const positions = [worldPos1, worldPos2, worldPos3];
            
                    // Aktualny i następny marker
                    const currentMarkerIndex = Math.floor(progress) % 3;
                    const nextMarkerIndex = (currentMarkerIndex + direction + 3) % 3;
            
                    const currentPos = positions[currentMarkerIndex];
                    const nextPos = positions[nextMarkerIndex];
            
                    // Obliczanie interpolacji pozycji
                    const interpolationFactor = progress % 1; // Ułamek wskazujący postęp między markerami
                    const interpolatedX = THREE.MathUtils.lerp(currentPos.x, nextPos.x, interpolationFactor);
                    const interpolatedY = THREE.MathUtils.lerp(currentPos.y, nextPos.y, interpolationFactor);
                    const interpolatedZ = THREE.MathUtils.lerp(currentPos.z, nextPos.z, interpolationFactor);
            
                    car.object3D.position.set(interpolatedX, interpolatedY, interpolatedZ);
            
                    // Obliczanie kąta rotacji
                    const angle = Math.atan2(nextPos.z - currentPos.z, nextPos.x - currentPos.x);
                    car.object3D.rotation.set(0, -angle, 0);
            
                    // Aktualizacja progresji ruchu
                    progress += 0.01 * direction;
                    if (progress >= 3) {
                        progress = 2;
                        direction = -1; // Zawracanie wstecz
                    } else if (progress < 0) {
                        progress = 0;
                        direction = 1; // Powrót do przodu
                    }
            
                } else {
                    car.setAttribute('visible', 'false'); // Ukrywanie samochodu, jeśli któryś marker nie jest widoczny
                }
            
                animationFrame = requestAnimationFrame(moveCar);
            }

            moveCar();
            window.addEventListener('unload', () => cancelAnimationFrame(animationFrame));
        </script>
    </a-scene>
</body>
</html>

