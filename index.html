<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AR.js - Car Moving Between 3 Markers</title>
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/jeromeetienne/ar.js/aframe/build/aframe-ar.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
<a-scene embedded arjs>
  
  <!-- Marker 1 (start) -->
  <a-marker preset="hiro" id="marker1">
    <a-cylinder height="2" radius="0.1" color="blue" position="0 1 0"></a-cylinder>
  </a-marker>

  <!-- Marker 2 (middle) -->
  <a-marker preset="kanji" id="marker2">
    <a-cylinder height="2" radius="0.1" color="red" position="0 1 0"></a-cylinder>
  </a-marker>

  <!-- Marker 3 (custom) -->
  <a-marker
    preset="custom"
    type="pattern"
    url="custom-marker.patt"
    id="marker3">
    <a-cylinder height="2" radius="0.1" color="green" position="0 1 0"></a-cylinder>
  </a-marker>

  <!-- Kamera -->
  <a-entity camera></a-entity>

  <!-- Samochód wstawiony bezpośrednio do sceny (nie jako child żadnego markera!) -->
  <a-entity
    id="movingCar"
    gltf-model="car2.glb"
    scale="0.2 0.2 0.2"
    visible="false">
  </a-entity>

  <script>
    const marker1 = document.querySelector('#marker1');
    const marker2 = document.querySelector('#marker2');
    const marker3 = document.querySelector('#marker3');

    const car = document.querySelector('#movingCar');

    let isMarker1Visible = false;
    let isMarker2Visible = false;
    let isMarker3Visible = false;

    // Słuchacze zdarzeń markerFound / markerLost
    marker1.addEventListener('markerFound', () => isMarker1Visible = true);
    marker1.addEventListener('markerLost',  () => isMarker1Visible = false);

    marker2.addEventListener('markerFound', () => isMarker2Visible = true);
    marker2.addEventListener('markerLost',  () => isMarker2Visible = false);

    marker3.addEventListener('markerFound', () => isMarker3Visible = true);
    marker3.addEventListener('markerLost',  () => isMarker3Visible = false);

    // progress: [0..3]
    //  - 0..1: jedziemy z marker1 do marker2
    //  - 1..2: jedziemy z marker2 do marker3
    //  - 2..3: jedziemy z marker3 do marker1
    let progress = 0;

    // direction = 1 (jazda w przód) lub -1 (jazda w tył)
    let direction = 1;

    let animationFrame;

    // Funkcja animująca ruch samochodu
    function moveCar() {
      // Tablica "fizycznych" obiektów (THREE.Object3D) naszych markerów
      const markers = [marker1, marker2, marker3];
      // Tablica widoczności
      const markersVisible = [isMarker1Visible, isMarker2Visible, isMarker3Visible];

      // Obliczamy, między którymi markerami teraz się poruszamy
      const currentSegment = Math.floor(progress);            // 0, 1 lub 2
      const nextSegment = (currentSegment + 1) % 3;           // (1,2,0) lub (2,0,1) ...

      // Jeśli oba markery danego odcinka są widoczne...
      if (markersVisible[currentSegment] && markersVisible[nextSegment]) {
        // Pokazujemy samochód
        car.setAttribute('visible', 'true');

        // Pobieramy pozycje ŚWIATOWE (world) dla wszystkich 3 markerów
        const positions = markers.map(m => {
          const wp = new THREE.Vector3();
          m.object3D.getWorldPosition(wp);
          return wp;
        });

        // Pozycja startowa aktualnego odcinka
        const startPos = positions[currentSegment];
        // Pozycja końcowa aktualnego odcinka
        const endPos = positions[nextSegment];

        // Jaki "ułamek drogi" pokonujemy na tym segmencie?
        // Np. progress=0.3 oznacza 30% drogi od marker1 do marker2 (odcinek 0→1)
        // progress=1.2 oznacza 20% drogi od marker2 do marker3 (odcinek 1→2), itd.
        const segmentFraction = progress - currentSegment;

        // Interpolacja liniowa od startPos do endPos
        const x = THREE.MathUtils.lerp(startPos.x, endPos.x, segmentFraction);
        const y = THREE.MathUtils.lerp(startPos.y, endPos.y, segmentFraction);
        const z = THREE.MathUtils.lerp(startPos.z, endPos.z, segmentFraction);

        // Ustawiamy pozycję samochodu w układzie świata
        car.object3D.position.set(x, y, z);

        // Wyznaczamy kąt obrotu – w kierunku markerów (endPos - startPos)
        let angle = Math.atan2(endPos.z - startPos.z, endPos.x - startPos.x);

        // Jeżeli jedziemy "wstecz" (direction = -1), odwracamy kąt
        if (direction === -1) {
          angle += Math.PI;
        }

        // A-Frame i Three.js mają inną oś „przodu” obiektu;
        // stąd negujemy angle na osi Y:
        car.object3D.rotation.set(0, -angle, 0);

        // Aktualizujemy progress
        progress += 0.01 * direction;

        // Jeśli "doszliśmy" do 3, to znaczy, że dojechaliśmy z marker3 do marker1
        // (koniec trasy w przód) i trzeba zawrócić
        if (progress > 3) {
          progress = 3;
          direction = -1; // cofamy
        } 
        // Jeśli zawracamy i progress < 0 – znowu przejazd w drugą stronę
        else if (progress < 0) {
          progress = 0;
          direction = 1; // do przodu
        }
      } else {
        // Któryś z markerów odcinka nie jest widoczny -> chowamy samochód
        car.setAttribute('visible', 'false');
      }

      animationFrame = requestAnimationFrame(moveCar);
    }

    moveCar();
    window.addEventListener('unload', () => cancelAnimationFrame(animationFrame));
  </script>
</a-scene>
</body>
</html>

